"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildWidgetTree = buildWidgetTree;
function buildWidgetTree(jsxTree) {
  try {
    const widgetTree = buildWidgetTreeInner(jsxTree);
    validateWidgetTree(widgetTree);
    return widgetTree;
  } catch (error) {
    if (error.message && error.message.includes('Invalid hook call')) {
      var _jsxTree$type;
      const widgetName = ((_jsxTree$type = jsxTree.type) === null || _jsxTree$type === void 0 ? void 0 : _jsxTree$type.name) ?? 'your widget';
      throw new Error(`Widget Error: Invalid Hook Call detected in ${widgetName}.
Possible causes:
1. You are using hooks (useState, useEffect) which are not supported.
2. The React Compiler (React 19) is transforming this component, but this library requires raw functions.
   Fix: Add "use no memo"; at the very top of your widget file to disable the compiler for this file.`);
    }
    throw error;
  }
}
function buildWidgetTreeInner(jsxTree) {
  var _jsxTree$type$process, _jsxTree$type2;
  if (typeof jsxTree === 'string' || typeof jsxTree === 'number') {
    return jsxTree;
  }
  while (!jsxTree.type.__name__) {
    jsxTree = jsxTree.type(jsxTree.props);
  }
  const {
    children,
    ...otherProps
  } = jsxTree.props;
  const childrenArray = children ? Array.isArray(children) ? children : [children] : [];
  const updatedChildren = ((_jsxTree$type$process = (_jsxTree$type2 = jsxTree.type).processChildren) === null || _jsxTree$type$process === void 0 ? void 0 : _jsxTree$type$process.call(_jsxTree$type2, otherProps, childrenArray)) ?? childrenArray ?? [];
  return {
    type: jsxTree.type.__name__,
    props: jsxTree.type.convertProps(otherProps),
    ...(updatedChildren ? {
      children: updatedChildren.filter(x => !!x).flat(1).map(x => buildWidgetTree(x)).flat(1)
    } : {})
  };
}
function validateWidgetTree(widgetTree) {
  throwIfNestedListWidget(widgetTree, false);
  const listWidgetCount = countListWidgets(widgetTree);
  if (listWidgetCount > 2) {
    throw new Error('You can have a maximum of two ListWidget(s)');
  }
}
function throwIfNestedListWidget(widgetTree) {
  let shouldThrow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (widgetTree.type === 'ListWidget') {
    if (shouldThrow) {
      throw new Error('You cannot have ListWidget inside other ListWidget');
    }
    (widgetTree.children ?? []).forEach(child => throwIfNestedListWidget(child, true));
  }
  (widgetTree.children ?? []).forEach(child => throwIfNestedListWidget(child, shouldThrow));
}
function countListWidgets(widgetTree) {
  if (widgetTree.type === 'ListWidget') {
    return 1;
  }
  return (widgetTree.children ?? []).reduce((memo, child) => memo + countListWidgets(child), 0);
}
//# sourceMappingURL=build-widget-tree.js.map