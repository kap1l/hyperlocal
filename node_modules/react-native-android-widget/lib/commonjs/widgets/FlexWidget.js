"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlexWidget = FlexWidget;
var _clickAction = require("./utils/click-action");
var _style = require("./utils/style.utils");
const GRAVITY = {
  START: 8388611,
  END: 8388613,
  TOP: 48,
  BOTTOM: 80,
  CENTER_HORIZONTAL: 1,
  CENTER_VERTICAL: 16
};
function FlexWidget(_ref) {
  let {
    children
  } = _ref;
  return children;
}
FlexWidget.__name__ = 'LinearLayoutWidget';
FlexWidget.convertProps = props => {
  var _props$style, _props$style2;
  return {
    ...(0, _style.convertCommonStyle)(props.style ?? {}),
    ...convertFlexStyle(props.style ?? {}),
    ...(0, _clickAction.convertClickAction)(props),
    ...((_props$style = props.style) !== null && _props$style !== void 0 && _props$style.flexGap ? {
      separator: {
        size: props.style.flexGap,
        color: (0, _style.convertColor)(props.style.flexGapColor ?? '#ffffff00')
      }
    } : {}),
    ...(props !== null && props !== void 0 && (_props$style2 = props.style) !== null && _props$style2 !== void 0 && _props$style2.overflow ? {
      overflow: props.style.overflow
    } : {})
  };
};
FlexWidget.processChildren = (_ref2, children) => {
  let {
    style
  } = _ref2;
  if (style !== null && style !== void 0 && style.justifyContent && ['space-around', 'space-between', 'space-evenly'].includes(style.justifyContent)) {
    const betweenFlex = style.justifyContent === 'space-around' ? 2 : 1;
    const showBeforeAndAfter = style.justifyContent !== 'space-between';
    const newChildren = children.reduce((memo, item, index) => {
      if (index > 0) {
        return [...memo, createSeparator(betweenFlex), item];
      }
      return [...memo, item];
    }, []);
    if (showBeforeAndAfter) {
      return [createSeparator(1), ...newChildren, createSeparator(1)];
    }
    return newChildren;
  }
  return children;
};
function createSeparator(betweenFlex) {
  return {
    type: FlexWidget,
    props: {
      children: [],
      style: {
        flex: betweenFlex
      }
    }
  };
}
function convertFlexStyle(style) {
  return {
    orientation: style.flexDirection === 'row' ? 'HORIZONTAL' : 'VERTICAL',
    ...(style.flex ? {
      weight: style.flex
    } : {}),
    gravity: getGravity(style)
  };
}
function getGravity(_ref3) {
  let {
    flexDirection,
    justifyContent,
    alignItems
  } = _ref3;
  let gravity = GRAVITY.START;
  switch (flexDirection === 'row' ? justifyContent : alignItems) {
    case 'flex-start':
      gravity = GRAVITY.START;
      break;
    case 'center':
      gravity = GRAVITY.CENTER_HORIZONTAL;
      break;
    case 'flex-end':
      gravity = GRAVITY.END;
      break;
    default:
      break;
  }
  switch (flexDirection === 'row' ? alignItems : justifyContent) {
    case 'flex-start':
      gravity |= GRAVITY.TOP;
      break;
    case 'center':
      gravity |= GRAVITY.CENTER_VERTICAL;
      break;
    case 'flex-end':
      gravity |= GRAVITY.BOTTOM;
      break;
    default:
      break;
  }
  return gravity;
}
//# sourceMappingURL=FlexWidget.js.map